
<!DOCTYPE html>
<html>
	<head>
		<meta charset="UTF-8" />
		<meta name="viewport" content="width=device-width, initial-scale=1.0, minimum-scale=1.0, maximum-scale=1.0, user-scalable=no" />

		<meta name="apple-mobile-web-app-status-bar-style" content="black" />
		<meta name="apple-mobile-web-app-capable" content="yes" />

		<link rel="shortcut icon" type="images/ico" href="favicon.ico" />
		<link rel="apple-touch-icon" href="apple-touch-icon.png" />

		<title>PurpleMaze, a (purple) tile-based maze game created with Vue.js</title>

		<link type="text/css" rel="stylesheet" href="css/maze.css" />

		<script src="https://cdn.jsdelivr.net/npm/vue"></script>
		<script src="js/maze.js"></script>

	</head>
	<body>

		<div class="app"
			tabindex="-1"
			v-on:keydown.up="move('up')"
			v-on:keydown.right="move('right')"
			v-on:keydown.down="move('down')"
			v-on:keydown.left="move('left')"
			v-on:keydown.enter="start( finished )"
			v-bind:class="[ tileSizeClass, { 'app_3d': config.perspective } ]"
		>

			<div class="player"></div>
			<div class="game">

				<!-- the maze -->
				<div class="maze"
					v-bind:style="mazePosition"
				>
					<span class="tile" 
						v-for="tile in maze.tiles" 
						v-bind:style="{ transform: 'translate(' + ( 100 * tile.position[ 0 ] ) + '%, ' + ( 100 * tile.position[ 1 ] ) + '%)' }"
						v-bind:class="{ 
							tile_top: tile.top,
							tile_right: tile.right, 
							tile_bottom: tile.bottom, 
							tile_left: tile.left
						}"
					>
						<span class="tile__finish" 
							v-if="tile.finish"></span>	
					</span>
				</div>


				<!-- navigation -->
				<div class="navigation"
					v-show="!finished"
				>
					<a class="navigation__move-up"
						v-on:click="move('up')"></a>
					<a class="navigation__move-right"
						v-on:click="move('right')"></a>
					<a class="navigation__move-down"
						v-on:click="move('down')"></a>
					<a class="navigation__move-left"
						v-on:click="move('left')"></a>
				</div>

			</div>


			<!-- finish -->
			<div class="finish"
				v-bind:class="{ finish_showing: finished }"
			>
				<h1>Congratulations!</h1>
				<p>You found the white circle</p>
				<a href="#" 
					v-on:click.prevent="start( true )">Create new maze</a>
			</div>


			<!-- menu / settings + text -->
			<div class="menu"
				v-bind:class="{ menu_opened: config.menuOpen }"
			>
				<div class="settings">
					<a href="#"
						class="settings__icon"
						v-on:click.prevent="config.menuOpen = !config.menuOpen">?</a>

					<span class="settings__compass"
						v-show="maze.finish && !finished"
						v-bind:style="{ transform: 'rotate(' + direction + 'deg)' }"
					></span>

					<span class="settings__label">Roads:</span>
					<select class="settings__maxtiles"
						v-model="options.maxTiles"
						v-on:change="start( finished )"
					>
						<option>50</option>
						<option>100</option>
						<option>150</option>
						<option>200</option>
						<option>300</option>
						<option>400</option>
						<option>500</option>
						<option>750</option>
						<option>1000</option>
						<option>1250</option>
						<option>1500</option>
						<option>2000</option>
						<option>2500</option>
						<option>3000</option>
					</select>
					
					<a href="#"
						class="button settings__button"
						v-on:click.prevent="start( true )">create<span> maze</span></a>
				</div>

				<div class="text">
					<div class="text__howto">
						<h2>How to play</h2>
						<ol>
							<li>Create a new maze by setting an amount of roads and click the "create" button.</li>
							<li>Check the compass to locate the white circle.</li>
							<li v-if="config.touchscreen">Touch the sides of the screen to navigate through the maze.</li>
							<li v-else>Use the keyboard to navigate through the maze.</li>
							<li>Find the white circle.</li>
							<li>Party hard :)</li>
						</ol>
					</div>

					<div class="text__tilesize">
						<h2>Tile size</h2>
						<p>
							<label>
								<input type="radio"
									name="tileSize"
									v-model="options.tileSize" value="s" /> <small>Small</small>
							</label>
							<label>
								<input type="radio"
									name="tileSize"
									v-model="options.tileSize" value="m" /> Medium
							</label>
							<label>
								<input type="radio"
									name="tileSize"
									v-model="options.tileSize" value="l" /> <big>Large</big>
							</label>
						</p>
					</div>

					<div class="text__perspective">
						<h2>Point of view</h2>
						<p>
							<label>
								<input type="radio"
									name="perspective"
									v-model="config.perspective" value="" /> Flat
							</label>
							<label>
								<input type="radio"
									name="perspective"
									v-model="config.perspective" value="semi" /> Birds eye
							</label>
							<label>
								<input type="radio"
									name="perspective"
									v-model="config.perspective" value="full" /> 3rd Person
							</label>
						</p>
					</div>

					<div class="text__about">
						<h2>About</h2>
						<p>This game is created for fun by <a href="http://www.frebsite.nl" target="_blank">Fred Heusschen</a> using <a href="http://vuejs.org" target="_blank">Vue.js</a>.</p>
					</div>

					<a href="#"
						class="button"
						v-on:click.prevent="config.menuOpen = false">OK, got it</a>
				</div>
			</div>

		</div>


		<script>
			var _maze, _vue;

			_vue = new Vue({
				el: '.app',
				data: {
					maze: {
						tiles 		: [],
						position 	: [ 0, 0 ],
						finish 		: null,
						rotation 	: 0
					},
					options		: {
						maxTiles 	: 300,
						bundled 	: true,
						tileSize 	: 'm'
					},
					config		: {
						touchscreen	: 'ontouchstart' in window,
						menuOpen	: false,
						perspective	: 'full'
					}
				},
				computed: {
					finished: function() {
						return this.maze.finish
							? this.maze.position[ 0 ] == this.maze.finish[ 0 ] && this.maze.position[ 1 ] == this.maze.finish[ 1 ]
							: false;
					},
					direction: function() {
						return this.maze.finish
							? this.maze.rotation + 180 - ( Math.atan2( this.maze.finish[ 0 ] - this.maze.position[ 0 ], this.maze.finish[ 1 ] - this.maze.position[ 1 ] ) * 180 / Math.PI ) % 360
							: 0
					},
					mazePosition: function()
					{
						var tx = -( 100 * this.maze.position[ 0 ] ),
							ty = -( 100 * this.maze.position[ 1 ] ),
							rx = ( 100 * this.maze.position[ 0 ] ) + 50,
							ry = ( 100 * this.maze.position[ 1 ] ) + 50;

						var css = {};

						css[ 'transform' ] = 'translate(' + tx + '%, ' + ty + '%)';
						if ( this.config.perspective )
						{
							css[ 'transform' ] += ' rotateX( 60deg )';
							css[ 'transform-origin' ] = rx + '% ' + ry + '% 0';
						}
						if ( this.config.perspective == 'full' )
						{
							css[ 'transform' ] += 'rotate(' + this.maze.rotation + 'deg)';
						}

						return css;
					},
					tileSizeClass: function() {
						return {
							'app__maze_tilesize-s': this.options.tileSize == 's',
							'app__maze_tilesize-m': this.options.tileSize == 'm',
							'app__maze_tilesize-l': this.options.tileSize == 'l'
						}
					}
				},
				methods: {
					move: function( dir ) {
						if ( this.config.perspective == 'full' )
						{
							var directions, rotation = 0;

							switch( dir)
							{
								case 'left':
									this.maze.rotation += 90;
									break;

								case 'right':
									this.maze.rotation -= 90;
									break;

								case 'up':
								case 'down':
									rotation = this.maze.rotation % 360;
									while ( rotation < 0 )
									{
										rotation += 360;
									}
									break;
							};
							switch( dir)
							{
								case 'up':
									directions = {
										0: 'up',
										90: 'left',
										180: 'down',
										270: 'right'
									};
									break;

								case 'down':
									directions = {
										0: 'down',
										90: 'right',
										180: 'up',
										270: 'left'
									};
									break;
							};
							if ( directions )
							{
								_maze.move( directions[ rotation ] );
							}
						}
						else
						{
							_maze.move( dir );
						}
					},
					start: function( create ) {
						if ( create )
						{
							_maze.create();
						}
					}
				}
			});

			_maze = new Maze( _vue );

		</script>
	</body>
</html>